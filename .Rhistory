parameter_hists <- function(prot, fishy = FALSE){
params <- parameters(prot, fishy)
p_roots <- sapply(params, function(elm) {
as.numeric(elm[["p.p_root"]])
})
h <- hist(p_roots, breaks = 30, plot = FALSE)
plot(h,  main = paste("Histogram of ",prot, " p") xlab = "p")
lh <- hist(log(p_roots), breaks = 30, plot = FALSE)
plot(lh,  main = paste("Histogram of ",prot, " log(p)") xlab = "p")
}
parameter_hists <- function(prot, fishy = FALSE){
params <- parameters(prot, fishy)
p_roots <- sapply(params, function(elm) {
as.numeric(elm[["p.p_root"]])
})
h <- hist(p_roots, breaks = 30, plot = FALSE)
plot(h,  main = paste("Histogram of ",prot, " p"), xlab = "p")
lh <- hist(log(p_roots), breaks = 30, plot = FALSE)
plot(lh,  main = paste("Histogram of ",prot, " log(p)"), xlab = "p")
}
parameter_hists("n1", TRUE)
parameter_hists <- function(prot, fishy = FALSE){
params <- parameters(prot, fishy)
p_roots <- sapply(params, function(elm) {
as.numeric(elm[["p.p_root"]])
})
h <- hist(p_roots, breaks = 30, plot = FALSE)
plot(h,  main = paste("Histogram of ",prot, " p"), xlab = "p")
lh <- hist(log(p_roots), breaks = 30, plot = FALSE)
plot(lh,  main = paste("Histogram of ",prot, " log(p)"), xlab = "log(p)")
}
parameter_hists("n2", TRUE)
parameter_hists("h1", TRUE)
parameter_hists("h3", TRUE)
hist(p_roots_h3[p_roots_h3 <4], breaks = 30, labels= TRUE)
hist(p_roots_h3[p_roots_h3 <4], breaks = 40, labels= TRUE)
median(p_roots_h3[p_roots_h3 >0])
mean(p_roots_h3[p_roots_h3 >0])
median((p_roots_h3[p_roots_h3 >0])[p_roots_h3 <4])
median(p_roots_h3[4>p_roots_h3 >0])
pr <-median(p_roots_h3[p_roots_h3 >0])
pr <-p_roots_h3[p_roots_h3 >0]
pr <-pr[pr < 4]
median(pr)
head(h1_params)
lambda_roots_h3 <- sapply(h3_params(h3_params[["p.p_root"]] <3), function(elm) {
as.numeric(elm[["lambda_weib"]])
})
lambda_roots_h3 <- sapply(h3_params[h3_params[["p.p_root"]] <3], function(elm) {
as.numeric(elm[["lambda_weib"]])
})
lambda_roots_h3
lambda_roots_h3 <- sapply(h3_params[h3_params[["p.p_root"]] <3], function(elm) {
elm
as.numeric(elm[["lambda_weib"]])
})
lambda_roots_h3 <- sapply(h3_params[h3_params[["p.p_root"]] <3], function(elm) {
print(elm)
as.numeric(elm[["lambda_weib"]])
})
h3_params_t <- h3_params[h3_params[["p.p_root"]] <3]
h3_params_t
h3_params[["p.p_root"]]
h3_params[1][["p.p_root"]]
h3_params[[1]][["p.p_root"]]
h3_params[[3]][["p.p_root"]]
h3_params_t <- sapply(h3_params, function(elm) {
print (elm[["p.p_root"]])
})
h3_max_proots <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) > 2) {TRUE}
else {FALSE}
})
lambda_roots_h3 <- sapply(h3_params[h3_max_proots], function(elm) {
print(elm)
as.numeric(elm[["lambda_weib"]])
})
lambda_roots_h3 <- sapply(h3_params[h3_max_proots], function(elm) {
print(elm)
as.numeric(elm["lambda_weib"])
})
hist(p_roots_h3, breaks = 30, labels= TRUE)
hist(lambda_roots_h3, breaks = 30, labels= TRUE)
lambda_roots_h3
lambda_roots_h3 <- sapply(h3_params[h3_max_proots], function(elm) {
print(elm)
as.numeric(elm["lambda_weib.lambda_root"])
})
lambda_roots_h3
hist(lambda_roots_h3, breaks = 30, labels= TRUE)
h3_max_proots <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) > 1.5) {TRUE}
else {FALSE}
})
lambda_roots_h3 <- sapply(h3_params[h3_max_proots], function(elm) {
print(elm)
as.numeric(elm["lambda_weib.lambda_root"])
})
hist(lambda_roots_h3, breaks = 30)
h3_max_proots <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) < 1) {TRUE}
else {FALSE}
})
lambda_roots_h3 <- sapply(h3_params[h3_max_proots], function(elm) {
as.numeric(elm["lambda_weib.lambda_root"])
})
hist(lambda_roots_h3, breaks = 30)
h3_max_proots <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) < 0.8) {TRUE}
else {FALSE}
})
lambda_roots_h3 <- sapply(h3_params[h3_max_proots], function(elm) {
as.numeric(elm["lambda_weib.lambda_root"])
})
hist(lambda_roots_h3, breaks = 30)
h3_max_proots <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) >3) {TRUE}
else {FALSE}
})
lambda_roots_h3 <- sapply(h3_params[h3_max_proots], function(elm) {
as.numeric(elm["lambda_weib.lambda_root"])
})
hist(lambda_roots_h3, breaks = 30)
boolean <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) > threshold) {right == TRUE}
else {right == FALSE}
})
threshold <- 3
boolean <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) > threshold) {right == TRUE}
else {right == FALSE}
})
right <- TRUE
boolean <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) > threshold) {right == TRUE}
else {right == FALSE}
})
lambdas <- sapply(h3_params[boolean], function(elm) {
as.numeric(elm["lambda_weib.lambda_root"])
})
hist(lambdas, breaks = 30)
lambda_hist <- function(params, threshold, right = TRUE){
p_roots <- sapply(h3_params, function(elm) {
as.numeric(elm[["p.p_root"]])
})
boolean <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) > threshold) {right == TRUE}
else {right == FALSE}
})
lambda <- sapply(h3_params[boolean], function(elm) {
as.numeric(elm["lambda_weib.lambda_root"])
})
if (right){
sign = ">"
}
else {
sign = "<="
}
h <- hist(lambda, breaks = 30, plot = FALSE)
plot(h,  main = paste("Histogram of ",prot, " lambda for p", sign, " ", threshold), xlab = "lambda")
}
lambda_hist(h3_params, 2, TRUE)
lambda_hist <- function(prot, params, threshold, right = TRUE){
p_roots <- sapply(h3_params, function(elm) {
as.numeric(elm[["p.p_root"]])
})
boolean <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) > threshold) {right == TRUE}
else {right == FALSE}
})
lambda <- sapply(h3_params[boolean], function(elm) {
as.numeric(elm["lambda_weib.lambda_root"])
})
if (right){
sign = ">"
}
else {
sign = "<="
}
h <- hist(lambda, breaks = 30, plot = FALSE)
plot(h,  main = paste("Histogram of ",prot, " lambda for p", sign, " ", threshold), xlab = "lambda")
}
lambda_hist("h3", h3_params, 2, TRUE)
lambda_hist("h3", h3_params, 4, TRUE)
lambda_hist("h3", h3_params, 1, TRUE)
n1_params <- parameters("n1", TRUE)
n2_params <- parameters("n2", TRUE)
lambda_hist("h1", h1_params, threshold = 1, right = FALSE)
minusp <-h1_params[h1_params[["p.p_root"]] < 0]
minusp
h1_params[["p.p_root"]]
h1_params[1][["p.p_root"]]
h1_params[[1]][["p.p_root"]]
boolean <- sapply(h3_params, function(elm) {
if (as.numeric(elm[["p.p_root"]]) < 0) {right == TRUE}
else {right == FALSE}
})
minusp <- h3_params[boolean]
minusp
prot <- "h3"
prot_data <-  read.csv(paste(c("C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/",prot,"_for_LRT.csv"), collapse=""),stringsAsFactors=FALSE)
splitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)
draw_function2(splitted,"175.INTNODE4215" )
draw_function2 <- function(splitted, anc_node){
node_data <- splitted[[anc_node]]
parms <- list(node_data = node_data, mutation_position = "end")
y <- sapply(seq(from = 0, to = 5, by = 0.01), function (elm){function_f2(elm,parms)})
plot( x = seq(from = 0, to = 5, by = 0.01), y, type = 'l', xlab = "p", ylab = "f2", axes=F, xaxt="n", yaxt="n", main = anc_node, ylim = c(-10, 5))
axis(1, pos=0)
axis(2, pos=0)
abline(v=0, h=0)
}
draw_function2(splitted,"175.INTNODE4215" )
draw_function2 <- function(splitted, anc_node){
node_data <- splitted[[anc_node]]
parms <- list(node_data = node_data, mutation_position = "end")
y <- sapply(seq(from = -10, to = 5, by = 0.01), function (elm){function_f2(elm,parms)})
plot( x = seq(from = -10, to = 5, by = 0.01), y, type = 'l', xlab = "p", ylab = "f2", axes=F, xaxt="n", yaxt="n", main = anc_node, ylim = c(-10, 5))
axis(1, pos=0)
axis(2, pos=0)
abline(v=0, h=0)
}
draw_function2(splitted,"175.INTNODE4215" )
draw_function2 <- function(splitted, anc_node){
node_data <- splitted[[anc_node]]
parms <- list(node_data = node_data, mutation_position = "end")
y <- sapply(seq(from = -5, to = 5, by = 0.05), function (elm){function_f2(elm,parms)})
plot( x = seq(from = -5, to = 5, by = 0.05), y, type = 'l', xlab = "p", ylab = "f2", axes=F, xaxt="n", yaxt="n", main = anc_node, ylim = c(-10, 5))
axis(1, pos=0)
axis(2, pos=0)
abline(v=0, h=0)
}
draw_function2(splitted,"175.INTNODE4215" )
node_data <- splitted[["175.INTNODE4215"]]
mutation_position <- "end"
node_roots <- find_single_root(node_data, mutation_position)
all(!is.na(node_roots))
node_roots
all(!is.nan(node_roots))
is.nan(node_roots$lambda_root)
is.nan(node_roots["lambda_root"])
all(!is.infinite(node_roots))
parameters <-function(prot, tag, fishy = FALSE){
prot_data <-  read.csv(paste(c("C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/",prot,"_for_LRT.csv"), collapse=""),stringsAsFactors=FALSE)
splitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)
# roots <- lapply (splitted, find_single_root, mutation_position = "end")
parameters <- lapply (names(splitted), function(elm, mutation_position){
mutation_position <- mutation_position
node_data <- splitted[[elm]]
node_roots <- find_single_root(node_data, mutation_position)
if(!is.na(node_roots) && all(!is.na(node_roots)) && all(!is.infinite(node_roots)) && node_roots["p_precision"] < 1e-5  ){
# lr <-lrt (node_data, lambda_exp = node_roots["lambda_exp_root"], lambda_weib = node_roots["lambda_root"], p = node_roots["p_root"], fishy)
c(node = elm, lambda_exp = node_roots["lambda_exp_root"], lambda_weib = node_roots["lambda_root"], p = node_roots["p_root"])
}
}, mutation_position = "end")
parameters  <- Filter(Negate(is.null), parameters)
}
function_f2 <- function(x, parms){
node_data <- parms$node_data
mutation_position <- parms$mutation_position
if (mutation_position == "start"){
no_events_branches = node_data[node_data["event_indicator"]==0,]
}
else if (mutation_position == "end"){
no_events_branches = node_data
}
else {
stop('Value of mutation_position parameter must be either "start" or "end"')
}
# print ("no_events_branches")
# print (str(no_events_branches))
# print (class(no_events_branches))
D <- sum (node_data["event_indicator"])
apply_res1 <- apply( no_events_branches, 1,
function(elm){
if(!is.na(elm["event_indicator"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header
tbeta1 <- as.numeric(elm["t_branch_end"])
tbeta0 <- as.numeric(elm["t_branch_start"])
if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth
else {logtbeta0 <- log(tbeta0)}
if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation
else {
logtbeta1 <- log(tbeta1)
logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*((tbeta0/tbeta1)^x))
}
}
else { 0 }
})
#  print ("apply_res1")
#  print ("---str---")
#  print (str(apply_res1))
#  print ("---class---")
#  print (class(apply_res1))
#  print ("---contents---")
#  print (apply_res1)
apply_res2 <- apply( no_events_branches, 1,
function(elm){
if(!is.na(elm["event_indicator"])){
tbeta1 <- as.numeric(elm["t_branch_end"])
tbeta0 <- as.numeric(elm["t_branch_start"])
if (tbeta1 == 0) { 0 }
else {
(tbeta1^x)*(1-(tbeta0/tbeta1)^x)
}
}
else {0}
})
#  print ("apply_res2")
#  print ("---str---")
#  print (str(apply_res2))
#  print ("---class---")
#  print (class(apply_res2))
#  print ("---contents---")
#  print (apply_res2)
apply_res3 <- apply( node_data[node_data["event_indicator"]==1,], 1,
function(elm){
if(!is.na(elm["event_indicator"])){ #if (nrow(dataframe) == 0), apply still tries to apply the function to.. header? the list is not empty: it contains the header
if (mutation_position == "start"){talpha <- as.numeric(elm["t_branch_start"])}
else if (mutation_position == "end"){talpha <- as.numeric(elm["t_branch_end"])}
else {stop('Value of mutation_position parameter must be either "start" or "end"')}
if (talpha == 0){logtalpha = 0}
else {logtalpha = log(talpha)}
logtalpha
}
else {0}
}
)
#  print ("apply_res3")
#  print ("---str---")
#  print (str(apply_res3))
#  print ("---class---")
#  print (class(apply_res3))
#  print ("---contents---")
#  print (apply_res3)
# f2 <- x*D*sum( apply_res1 )/sum( apply_res2 ) - x*sum( apply_res3 ) - D
f2 <- D*sum( apply_res1 )/sum( apply_res2 ) - sum( apply_res3 ) - D/p
f2
}
draw_function2(splitted,"175.INTNODE4215" )
function_f2 <- function(x, parms){
node_data <- parms$node_data
mutation_position <- parms$mutation_position
if (mutation_position == "start"){
no_events_branches = node_data[node_data["event_indicator"]==0,]
}
else if (mutation_position == "end"){
no_events_branches = node_data
}
else {
stop('Value of mutation_position parameter must be either "start" or "end"')
}
# print ("no_events_branches")
# print (str(no_events_branches))
# print (class(no_events_branches))
D <- sum (node_data["event_indicator"])
apply_res1 <- apply( no_events_branches, 1,
function(elm){
if(!is.na(elm["event_indicator"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header
tbeta1 <- as.numeric(elm["t_branch_end"])
tbeta0 <- as.numeric(elm["t_branch_start"])
if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth
else {logtbeta0 <- log(tbeta0)}
if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation
else {
logtbeta1 <- log(tbeta1)
logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*((tbeta0/tbeta1)^x))
}
}
else { 0 }
})
#  print ("apply_res1")
#  print ("---str---")
#  print (str(apply_res1))
#  print ("---class---")
#  print (class(apply_res1))
#  print ("---contents---")
#  print (apply_res1)
apply_res2 <- apply( no_events_branches, 1,
function(elm){
if(!is.na(elm["event_indicator"])){
tbeta1 <- as.numeric(elm["t_branch_end"])
tbeta0 <- as.numeric(elm["t_branch_start"])
if (tbeta1 == 0) { 0 }
else {
(tbeta1^x)*(1-(tbeta0/tbeta1)^x)
}
}
else {0}
})
#  print ("apply_res2")
#  print ("---str---")
#  print (str(apply_res2))
#  print ("---class---")
#  print (class(apply_res2))
#  print ("---contents---")
#  print (apply_res2)
apply_res3 <- apply( node_data[node_data["event_indicator"]==1,], 1,
function(elm){
if(!is.na(elm["event_indicator"])){ #if (nrow(dataframe) == 0), apply still tries to apply the function to.. header? the list is not empty: it contains the header
if (mutation_position == "start"){talpha <- as.numeric(elm["t_branch_start"])}
else if (mutation_position == "end"){talpha <- as.numeric(elm["t_branch_end"])}
else {stop('Value of mutation_position parameter must be either "start" or "end"')}
if (talpha == 0){logtalpha = 0}
else {logtalpha = log(talpha)}
logtalpha
}
else {0}
}
)
#  print ("apply_res3")
#  print ("---str---")
#  print (str(apply_res3))
#  print ("---class---")
#  print (class(apply_res3))
#  print ("---contents---")
#  print (apply_res3)
# f2 <- x*D*sum( apply_res1 )/sum( apply_res2 ) - x*sum( apply_res3 ) - D
f2 <- D*sum( apply_res1 )/sum( apply_res2 ) - sum( apply_res3 ) - D/x
f2
}
draw_function2(splitted,"175.INTNODE4215" )
function_f2 <- function(x, parms){
node_data <- parms$node_data
mutation_position <- parms$mutation_position
if (mutation_position == "start"){
no_events_branches = node_data[node_data["event_indicator"]==0,]
}
else if (mutation_position == "end"){
no_events_branches = node_data
}
else {
stop('Value of mutation_position parameter must be either "start" or "end"')
}
# print ("no_events_branches")
# print (str(no_events_branches))
# print (class(no_events_branches))
D <- sum (node_data["event_indicator"])
apply_res1 <- apply( no_events_branches, 1,
function(elm){
if(!is.na(elm["event_indicator"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header
tbeta1 <- as.numeric(elm["t_branch_end"])
tbeta0 <- as.numeric(elm["t_branch_start"])
if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth
else {logtbeta0 <- log(tbeta0)}
if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation
else {
logtbeta1 <- log(tbeta1)
logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*((tbeta0/tbeta1)^x))
}
}
else { 0 }
})
#  print ("apply_res1")
#  print ("---str---")
#  print (str(apply_res1))
#  print ("---class---")
#  print (class(apply_res1))
#  print ("---contents---")
#  print (apply_res1)
apply_res2 <- apply( no_events_branches, 1,
function(elm){
if(!is.na(elm["event_indicator"])){
tbeta1 <- as.numeric(elm["t_branch_end"])
tbeta0 <- as.numeric(elm["t_branch_start"])
if (tbeta1 == 0) { 0 }
else {
(tbeta1^x)*(1-(tbeta0/tbeta1)^x)
}
}
else {0}
})
#  print ("apply_res2")
#  print ("---str---")
#  print (str(apply_res2))
#  print ("---class---")
#  print (class(apply_res2))
#  print ("---contents---")
#  print (apply_res2)
apply_res3 <- apply( node_data[node_data["event_indicator"]==1,], 1,
function(elm){
if(!is.na(elm["event_indicator"])){ #if (nrow(dataframe) == 0), apply still tries to apply the function to.. header? the list is not empty: it contains the header
if (mutation_position == "start"){talpha <- as.numeric(elm["t_branch_start"])}
else if (mutation_position == "end"){talpha <- as.numeric(elm["t_branch_end"])}
else {stop('Value of mutation_position parameter must be either "start" or "end"')}
if (talpha == 0){logtalpha = 0}
else {logtalpha = log(talpha)}
logtalpha
}
else {0}
}
)
#  print ("apply_res3")
#  print ("---str---")
#  print (str(apply_res3))
#  print ("---class---")
#  print (class(apply_res3))
#  print ("---contents---")
#  print (apply_res3)
f2 <- x*D*sum( apply_res1 )/sum( apply_res2 ) - x*sum( apply_res3 ) - D
f2
}
prs <- c(2.7, 0.003, 0.56, 0.004, 5, 0.03, 1.1, 0.006)
mprs <- matrix(prs, ncol =2, nrow = 3)
mprs <- matrix(prs, ncol =2, nrow = 4)
mprs
?matrix
mprs <- matrix(prs, ncol =2, nrow = 4, byrow = TRUE)
mprs
graph_data <-read.csv("C:/Users/weidewind/Documents/CMD/Coevolution/Influenza/perlOutput/Output/egor_h3.csv")
graph_data <-data.frame("radius"=graph_data$radius, "site_node"=paste(graph_data$site, graph_data$node, sep="_"), "density"=graph_data$density)
h3_chosen <- c("161_INTNODE3854")
plots <-plot_substs(as.character(h3_chosen), graph_data, "h3_chosen_plot_")
